from cryptography.hazmat.primitives.ciphers.algorithms import AES
from cryptography.hazmat.primitives.ciphers import Cipher, modes
from cryptography.hazmat.backends import default_backend
from os import urandom
from cryptography.hazmat.primitives import padding
from src.encrypter.encryptor import Encryptor


class AESEncrypt(Encryptor):

    def encrypt(self, message_text, key=None):
        """
        Encrypts a message using AES-256 bit

        :param message_text: a byte String containing the encoded message text
        :param key: (optional) a byte String representing an AES key. Must be 256 bits in length
        :return: a byte String containing the encrypted text, a byte String containing the AES key (respectively)
        """
        if not isinstance(message_text, bytes):  # this also captures message_text == None
            raise TypeError("The argument 'message_text' is not of type 'bytes'")

        if key is None:
            key = self.get_key()

        elif not isinstance(key, bytes):
            raise TypeError("The argument 'key' is not of type 'bytes'")

        elif len(key) != 32:
            raise ValueError("The argument 'key' is not 256 bits in length")

        algorithm = AES(key)
        cipher = Cipher(algorithm, mode=modes.CBC(self.get_iv()), backend=default_backend())

        # .update() encrypts the message and .finalize() returns the encrypted data
        encrypted_text = cipher.encryptor().update(self.pad_data(message_text)) + cipher.encryptor().finalize()
        return encrypted_text, key

    def get_key(self):
        """
        Randomly generates a 256-bit AES key

        :return: a randomly generated byte String that is 32 bytes (or 256 bits) in length
        """
        return urandom(32)

    def get_iv(self):
        """
        Randomly generates an initial vector for the Cipher Block Chaining mode of encryption

        :return: a byte String that is 16 bytes (128-bits) in length
        """
        return urandom(16)

    def pad_data(self, message):
        """
        Pads the message if needed

        :param message: a byte String containing the non-encrypted message
        :return: a byte String that will be a multiple the AES 128-bit block size
        """
        if message is None:
            message = ""

        elif not isinstance(message, bytes):
            raise ValueError("The argument 'message' is not of type 'bytes'")

        # if the message is multiple of the 128-bit block size (16 bytes) then no padding is needed
        if len(message) % 16 == 0:
            return message
        else:
            padder = padding.PKCS7(128).padder()
            padded_data = padder.update(message)  # returns the additional padded data
            padded_data += padder.finalize()  # concatenates the padded data with the original data
            return padded_data




